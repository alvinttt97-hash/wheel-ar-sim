<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>AR Wheel Overlay (2D)</title>
  <style>
    :root {
      --ui-bg: rgba(0,0,0,0.55);
      --ui-blur: 8px;
      --accent: #facc15; /* yellow */
      --text: #fff;
    }
    html, body { height: 100%; margin: 0; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: var(--text); }
    #app { position: fixed; inset: 0; overflow: hidden; }
    /* Camera video */
    #camera { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; background: #000; transform: scaleX(var(--mirror, 1)); }

    /* Wheel overlay container */
    #overlay { position: absolute; inset: 0; touch-action: none; z-index: 2; }
    #wheel { position: absolute; left: 50%; top: 50%; transform-origin: 50% 50%; will-change: transform; pointer-events: auto; display: block; }

    /* Safe UI area */
    .hud { position: absolute; left: 0; right: 0; display: flex; gap: .5rem; padding: .5rem .75rem; backdrop-filter: blur(var(--ui-blur)); background: var(--ui-bg); z-index: 3; }
    #topbar { top: 0; align-items: center; justify-content: space-between; }
    #bottombar { bottom: 0; flex-wrap: wrap; align-items: center; justify-content: center; }

    button, .seg { appearance: none; border: 1px solid #555; background: rgba(40,40,40,.7); color: var(--text); padding: .55rem .7rem; border-radius: 999px; font-size: .95rem; display: inline-flex; align-items: center; gap: .45rem; cursor: pointer; }
    button:hover { background: rgba(60,60,60,.8); }
    button.primary { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(250,204,21,.2) inset; }
    input[type=range] { width: 160px; }
    label { font-size: .85rem; opacity: .9; }

    /* Crosshair guide */
    #aim { position: absolute; left: 50%; top: 50%; width: 180px; height: 180px; transform: translate(-50%, -50%); pointer-events: none; opacity: .22; filter: drop-shadow(0 1px 1px rgba(0,0,0,.8)); z-index: 1; }

    /* Toast */
    #toast { position: absolute; left: 50%; bottom: 80px; transform: translateX(-50%); background: rgba(0,0,0,.7); padding: .6rem .8rem; border-radius: 10px; font-size: .9rem; display: none; z-index: 4; }

    /* iOS file input hint */
    .filelbl { border: 1px dashed #666; border-radius: 10px; padding: .35rem .6rem; cursor: pointer; }

    /* Small screens */
    @media (max-width: 400px) {
      input[type=range] { width: 120px; }
      #aim { width: 140px; height: 140px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <video id="camera" autoplay playsinline muted></video>

    <!-- Optional crosshair ring to help align wheel center to hub -->
    <svg id="aim" viewBox="0 0 200 200" aria-hidden="true">
      <circle cx="100" cy="100" r="95" fill="none" stroke="#fff" stroke-width="2" stroke-dasharray="5 6"/>
      <circle cx="100" cy="100" r="4" fill="#fff"/>
      <line x1="0" y1="100" x2="200" y2="100" stroke="#fff" stroke-width="1" opacity=".6"/>
      <line x1="100" y1="0" x2="100" y2="200" stroke="#fff" stroke-width="1" opacity=".6"/>
    </svg>

    <div id="overlay">
      <img id="wheel" src="" alt="Wheel overlay" draggable="false" />
    </div>

    <!-- Top bar -->
    <div id="topbar" class="hud">
      <div style="display:flex; gap:.5rem; align-items:center;">
        <button id="startBtn" class="primary">Start Camera</button>
        <button id="flipBtn" title="Switch camera">Flip</button>
        <button id="snapBtn" title="Save photo">Snapshot</button>
        <button id="resetBtn" title="Reset transform">Reset</button>
      </div>
      <div style="display:flex; gap:.5rem; align-items:center;">
        <input id="file" type="file" accept="image/*" hidden />
        <label for="file" class="filelbl" title="Transparent PNG/WebP works best">Upload Wheel</label>
        <button id="sampleBtn" title="Load sample wheel">Sample</button>
      </div>
    </div>

    <!-- Bottom bar controls -->
    <div id="bottombar" class="hud">
      <div class="seg"><label>Size</label> <input id="size" type="range" min="10" max="200" value="70"/></div>
      <div class="seg"><label>Opacity</label> <input id="opacity" type="range" min="10" max="100" value="100"/></div>
      <div class="seg"><label>Rotate</label> <input id="rotate" type="range" min="0" max="360" value="0"/></div>
      <div class="seg"><label><input id="lockCenter" type="checkbox" checked /> Lock to center</label></div>
      <div class="seg"><label><input id="mirror" type="checkbox"/> Mirror</label></div>
      <div class="seg"><label><input id="ringGuide" type="checkbox" checked/> Guide</label></div>
    </div>

    <div id="toast" role="status" aria-live="polite"></div>
  </div>

  <canvas id="capture" width="1080" height="1920" style="display:none"></canvas>

  <script>
    // ===== DOM refs
    const video = document.getElementById('camera');
    const overlay = document.getElementById('overlay');
    const wheel = document.getElementById('wheel');

    const startBtn = document.getElementById('startBtn');
    const flipBtn = document.getElementById('flipBtn');
    const snapBtn = document.getElementById('snapBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('file');
    const sampleBtn = document.getElementById('sampleBtn');

    const size = document.getElementById('size');
    const opacity = document.getElementById('opacity');
    const rotate = document.getElementById('rotate');
    const lockCenter = document.getElementById('lockCenter');
    const mirrorChk = document.getElementById('mirror');
    const ringGuideChk = document.getElementById('ringGuide');
    const aim = document.getElementById('aim');
    const toast = document.getElementById('toast');
    const capture = document.getElementById('capture');

    let currentStream = null;
    let useBack = true;

    // Wheel transform state
    let pos = { x: 0, y: 0 }; // offset from center (px)
    let scale = 0.7; // 0-2
    let angle = 0; // deg

    function updateWheelTransform() {
      const { innerWidth: w, innerHeight: h } = window;
      const px = lockCenter.checked ? 0 : pos.x;
      const py = lockCenter.checked ? 0 : pos.y;
      const sizePct = Number(size.value) / 100; // fraction of min(view width,height)
      const minDim = Math.min(w, h);
      const dim = minDim * sizePct;
      wheel.style.width = `${dim}px`;
      wheel.style.height = `${dim}px`;
      wheel.style.left = '50%';
      wheel.style.top = '50%';
      wheel.style.opacity = Number(opacity.value) / 100;
      angle = Number(rotate.value);
      wheel.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px)) rotate(${angle}deg) scale(${scale})`;
    }

    size.addEventListener('input', updateWheelTransform);
    opacity.addEventListener('input', updateWheelTransform);
    rotate.addEventListener('input', updateWheelTransform);
    lockCenter.addEventListener('change', updateWheelTransform);
    mirrorChk.addEventListener('change', () => {
      document.documentElement.style.setProperty('--mirror', mirrorChk.checked ? -1 : 1);
      showToast(mirrorChk.checked ? 'Mirrored' : 'Mirror off');
    });
    ringGuideChk.addEventListener('change', () => aim.style.display = ringGuideChk.checked ? 'block' : 'none');

    async function startCamera() {
      try {
        if (currentStream) {
          currentStream.getTracks().forEach(t => t.stop());
        }
        const constraints = {
          audio: false,
          video: {
            facingMode: useBack ? { ideal: 'environment' } : 'user',
            width: { ideal: 1920 }, height: { ideal: 1080 }
          }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        await video.play();
        showToast('Camera started');
      } catch (err) {
        console.error(err);
        alert('Unable to access camera. Make sure you granted permission and are using HTTPS.');
      }
    }

    function stopCamera() {
      if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    }

    startBtn.addEventListener('click', startCamera);
    flipBtn.addEventListener('click', async () => { useBack = !useBack; await startCamera(); });

    // Load sample transparent PNG (data URI embedded for offline/demo)
    const SAMPLE_WHEEL =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAACgCAYAAAB6m3qTAAABbklEQVR4nO3RMQEAIAwEsdP+v2Qp9g0wC8mKk5kH1mL8vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwEwDgY9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AAJ4BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwK3r1HAAEwE0GxAAAAAElFTkSuQmCC';

    sampleBtn.addEventListener('click', () => {
      wheel.src = SAMPLE_WHEEL;
      wheel.style.visibility = 'visible';
      updateWheelTransform();
      showToast('Sample wheel loaded');
    });

    // Use DataURL loader (more compatible on iOS than blob URLs in some contexts)
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) { showToast('No file selected'); return; }
      const type = (f.type || '').toLowerCase();
      const name = (f.name || '').toLowerCase();

      if (name.endsWith('.heic') || name.endsWith('.heif') || type.includes('heic') || type.includes('heif')) {
        alert('HEIC/HEIF images from iPhone are not supported by browsers directly. Please export as PNG/JPG or set Camera → Formats → Most Compatible.');
        return;
      }
      if (type && !type.startsWith('image/')) {
        alert('Please upload an image file (PNG/JPG/WebP).');
        return;
      }
      const reader = new FileReader();
      reader.onerror = () => alert('Could not read image. Try a smaller file.');
      reader.onload = () => {
        wheel.onload = () => { wheel.style.visibility = 'visible'; updateWheelTransform(); };
        wheel.onerror = () => { wheel.style.visibility = 'hidden'; alert('Could not load image. Try PNG/JPG or a smaller file.'); };
        wheel.src = String(reader.result);
        showToast('Wheel loaded');
      };
      reader.readAsDataURL(f);
    });

    // Pointer/touch gestures (drag, pinch-to-zoom, rotate)
    const active = new Map(); // pointerId -> {x,y}

    function onPointerDown(e) {
      try { wheel.setPointerCapture(e.pointerId); } catch(_) {}
      active.set(e.pointerId, { x: e.clientX, y: e.clientY });
    }
    function onPointerMove(e) {
      if (!active.has(e.pointerId)) return;
      const prev = active.get(e.pointerId);
      active.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (active.size === 1) {
        // drag
        if (!lockCenter.checked) {
          pos.x += e.clientX - prev.x;
          pos.y += e.clientY - prev.y;
          updateWheelTransform();
        }
      } else if (active.size >= 2) {
        // pinch/rotate using first two pointers
        const ids = [...active.keys()].slice(0,2);
        const p0 = active.get(ids[0]);
        const p1 = active.get(ids[1]);
        const p0Prev = ids[0] === e.pointerId ? prev : p0; // approx
        const p1Prev = p1; // rough
        const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
        const ang = (a,b)=>Math.atan2(b.y-a.y, b.x-a.x);

        const dNow = dist(p0, p1);
        const dPrev = dist(p0Prev, p1Prev);
        if (dPrev > 0) {
          const factor = dNow / dPrev;
          scale = Math.min(2, Math.max(0.2, scale * factor));
        }
        const aNow = ang(p0, p1);
        const aPrev = ang(p0Prev, p1Prev);
        const deltaDeg = (aNow - aPrev) * 180 / Math.PI;
        rotate.value = ( (Number(rotate.value) + deltaDeg) % 360 + 360 ) % 360;
        updateWheelTransform();
      }
    }
    function onPointerUp(e) { active.delete(e.pointerId); }

    wheel.addEventListener('pointerdown', onPointerDown);
    wheel.addEventListener('pointermove', onPointerMove);
    wheel.addEventListener('pointerup', onPointerUp);
    wheel.addEventListener('pointercancel', onPointerUp);

    // Snapshot (composite camera + wheel into a PNG)
    snapBtn.addEventListener('click', async () => {
      if (!video.videoWidth) return alert('Camera not ready.');
      const cw = capture.width, ch = capture.height;
      const ctx = capture.getContext('2d');
      ctx.clearRect(0,0,cw,ch);

      const vW = video.videoWidth, vH = video.videoHeight;
      const canvasAR = cw / ch;
      const videoAR = vW / vH;
      let sx, sy, sw, sh;
      if (videoAR > canvasAR) {
        sh = vH; sw = vH * canvasAR; sx = (vW - sw)/2; sy = 0;
      } else {
        sw = vW; sh = vW / canvasAR; sx = 0; sy = (vH - sh)/2;
      }
      ctx.save();
      if (mirrorChk.checked) { ctx.translate(cw, 0); ctx.scale(-1, 1); }
      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, cw, ch);
      ctx.restore();

      const w = window.innerWidth, h = window.innerHeight;
      const minDim = Math.min(w, h);
      const dim = minDim * (Number(size.value)/100) * scale;
      const cx = cw/2 + (lockCenter.checked ? 0 : pos.x * (cw/w));
      const cy = ch/2 + (lockCenter.checked ? 0 : pos.y * (ch/h));
      const img = wheel;
      if (img && img.complete && img.naturalWidth) {
        ctx.save();
        ctx.globalAlpha = Number(opacity.value)/100;
        ctx.translate(cx, cy);
        ctx.rotate(Number(rotate.value) * Math.PI/180);
        ctx.drawImage(img, -dim/2, -dim/2, dim, dim);
        ctx.restore();
      }

      const data = capture.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = data; a.download = `wheel-sim-${Date.now()}.png`; a.click();
      showToast('Snapshot saved');
    });

    resetBtn.addEventListener('click', () => {
      pos = { x: 0, y: 0 }; scale = 0.7; rotate.value = 0; size.value = 70; opacity.value = 100; wheel.style.visibility = 'hidden'; updateWheelTransform(); showToast('Reset');
    });

    function showToast(msg) {
      toast.textContent = msg; toast.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toast.style.display='none', 1500);
    }

    // Initial state: hide until a real image is set so we don't see a broken icon
    wheel.style.pointerEvents = 'auto';
    wheel.style.userSelect = 'none';
    const EMPTY_PIXEL = 'data:image/gif;base64,R0lGODlhAQABAAAAACw='; // 1x1 transparent
    wheel.src = EMPTY_PIXEL;
    wheel.style.visibility = 'hidden';
    updateWheelTransform();

    // Resize handling keeps overlay proportionate
    window.addEventListener('resize', updateWheelTransform);

    // ===== Self tests
    (function selfTest(){
      try {
        console.group('AR Wheel Overlay — Self Test');
        console.assert(video instanceof HTMLVideoElement, 'video element exists');
        console.assert(wheel instanceof HTMLImageElement, 'wheel image exists');
        const before = wheel.style.transform; rotate.value = 15; updateWheelTransform();
        console.assert(wheel.style.transform !== before, 'transform updates when controls change');
        const img = new Image();
        img.onload = () => console.assert(img.naturalWidth > 0, 'sample wheel data URI loads');
        img.src = SAMPLE_WHEEL;
        console.groupEnd();
      } catch (e) { console.error('Self test failed', e); }
    })();

    // iOS hint: require a user gesture to start camera; Start button provided
    // HTTPS is required on mobile browsers for getUserMedia.
  </script>
</body>
</html>
