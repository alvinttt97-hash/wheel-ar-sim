<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>AR Wheel Overlay (2D)</title>
  <style>
    :root {
      --ui-bg: rgba(0,0,0,0.55);
      --ui-blur: 8px;
      --accent: #facc15; /* yellow */
      --text: #fff;
    }
    html, body { height: 100%; margin: 0; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: var(--text); }
    #app { position: fixed; inset: 0; overflow: hidden; }

    /* Camera video layer */
    #camera { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; background: #000; transform: scaleX(var(--mirror, 1)); z-index: 0; }

    /* Guides */
    #aim { position: absolute; left: 50%; top: 50%; width: 180px; height: 180px; transform: translate(-50%, -50%); pointer-events: none; opacity: .22; filter: drop-shadow(0 1px 1px rgba(0,0,0,.8)); z-index: 1; }

    /* Wheel overlay */
    #overlay { position: absolute; inset: 0; touch-action: none; z-index: 2; }
    #wheel { position: absolute; left: 50%; top: 50%; transform-origin: 50% 50%; will-change: transform; pointer-events: auto; display: block; background: transparent !important; mix-blend-mode: normal; }

    /* HUD */
    .hud { position: absolute; left: 0; right: 0; display: flex; gap: .5rem; padding: .5rem .75rem; backdrop-filter: blur(var(--ui-blur)); background: var(--ui-bg); z-index: 3; }
    #topbar { top: 0; align-items: center; justify-content: space-between; }
    #bottombar { bottom: 0; flex-wrap: wrap; align-items: center; justify-content: center; }

    button, .seg { appearance: none; border: 1px solid #555; background: rgba(40,40,40,.7); color: var(--text); padding: .55rem .7rem; border-radius: 999px; font-size: .95rem; display: inline-flex; align-items: center; gap: .45rem; cursor: pointer; }
    button:hover { background: rgba(60,60,60,.8); }
    button.primary { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(250,204,21,.2) inset; }
    input[type=range] { width: 160px; }
    label { font-size: .85rem; opacity: .9; }

    /* Toast */
    #toast { position: absolute; left: 50%; bottom: 80px; transform: translateX(-50%); background: rgba(0,0,0,.7); padding: .6rem .8rem; border-radius: 10px; font-size: .9rem; display: none; z-index: 4; }

    /* File label */
    .filelbl { border: 1px dashed #666; border-radius: 10px; padding: .35rem .6rem; cursor: pointer; }

    /* Small screens */
    @media (max-width: 400px) {
      input[type=range] { width: 120px; }
      #aim { width: 140px; height: 140px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <video id="camera" autoplay playsinline muted></video>

    <!-- Crosshair ring to align wheel hub -->
    <svg id="aim" viewBox="0 0 200 200" aria-hidden="true">
      <circle cx="100" cy="100" r="95" fill="none" stroke="#fff" stroke-width="2" stroke-dasharray="5 6"/>
      <circle cx="100" cy="100" r="4" fill="#fff"/>
      <line x1="0" y1="100" x2="200" y2="100" stroke="#fff" stroke-width="1" opacity=".6"/>
      <line x1="100" y1="0" x2="100" y2="200" stroke="#fff" stroke-width="1" opacity=".6"/>
    </svg>

    <div id="overlay">
      <img id="wheel" src="" alt="Wheel overlay" draggable="false" />
    </div>

    <!-- Top bar -->
    <div id="topbar" class="hud">
      <div style="display:flex; gap:.5rem; align-items:center;">
        <button id="startBtn" class="primary">Start Camera</button>
        <button id="flipBtn" title="Switch camera">Flip</button>
        <button id="snapBtn" title="Save photo">Snapshot</button>
        <button id="resetBtn" title="Reset transform">Reset</button>
        <button id="hideUiBtn" title="Hide all controls for a clean capture (H)">Hide UI</button>
      </div>
      <div style="display:flex; gap:.5rem; align-items:center;">
        <input id="file" type="file" accept="image/*" hidden />
        <label for="file" class="filelbl" title="Transparent PNG/WebP works best">Upload Wheel</label>
        <button id="sampleBtn" title="Load sample wheel">Sample</button>
      </div>
    </div>

    <!-- Bottom bar controls -->
    <div id="bottombar" class="hud">
      <div class="seg"><label>Size</label> <input id="size" type="range" min="10" max="200" value="70"/></div>
      <div class="seg"><label>Opacity</label> <input id="opacity" type="range" min="10" max="100" value="100"/></div>
      <div class="seg"><label>Rotate</label> <input id="rotate" type="range" min="0" max="360" value="0"/></div>
      <div class="seg"><label><input id="lockCenter" type="checkbox" checked /> Lock to center</label></div>
      <div class="seg"><label><input id="mirror" type="checkbox"/> Mirror</label></div>
      <div class="seg"><label><input id="ringGuide" type="checkbox" checked/> Guide</label></div>
    </div>

    <div id="toast" role="status" aria-live="polite"></div>
  </div>

  <!-- Offscreen canvas for snapshots -->
  <canvas id="capture" width="1080" height="1920" style="display:none"></canvas>

  <script>
    // ===== DOM refs
    const video = document.getElementById('camera');
    const wheel = document.getElementById('wheel');
    const startBtn = document.getElementById('startBtn');
    const flipBtn = document.getElementById('flipBtn');
    const snapBtn = document.getElementById('snapBtn');
    const resetBtn = document.getElementById('resetBtn');
    const hideUiBtn = document.getElementById('hideUiBtn');
    const fileInput = document.getElementById('file');
    const sampleBtn = document.getElementById('sampleBtn');

    const size = document.getElementById('size');
    const opacity = document.getElementById('opacity');
    const rotate = document.getElementById('rotate');
    const lockCenter = document.getElementById('lockCenter');
    const mirrorChk = document.getElementById('mirror');
    const ringGuideChk = document.getElementById('ringGuide');
    const aim = document.getElementById('aim');
    const toast = document.getElementById('toast');
    const capture = document.getElementById('capture');

    let currentStream = null;
    let useBack = true;

    // Wheel transform state
    let pos = { x: 0, y: 0 }; // offset from center (px)
    let scale = 0.7; // extra pinch scaling (0.2-2)
    let angle = 0; // deg

    function updateWheelTransform() {
      const { innerWidth: w, innerHeight: h } = window;
      const px = lockCenter.checked ? 0 : pos.x;
      const py = lockCenter.checked ? 0 : pos.y;
      const sizePct = Number(size.value) / 100; // fraction of min(view width,height)
      const minDim = Math.min(w, h);
      const dim = minDim * sizePct;
      wheel.style.width = `${dim}px`;
      wheel.style.height = `${dim}px`;
      wheel.style.left = '50%';
      wheel.style.top = '50%';
      wheel.style.opacity = Number(opacity.value) / 100;
      angle = Number(rotate.value);
      wheel.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px)) rotate(${angle}deg) scale(${scale})`;
    }

    size.addEventListener('input', updateWheelTransform);
    opacity.addEventListener('input', updateWheelTransform);
    rotate.addEventListener('input', updateWheelTransform);
    lockCenter.addEventListener('change', updateWheelTransform);

    mirrorChk.addEventListener('change', () => {
      document.documentElement.style.setProperty('--mirror', mirrorChk.checked ? -1 : 1);
      showToast(mirrorChk.checked ? 'Mirrored' : 'Mirror off');
    });

    ringGuideChk.addEventListener('change', () => aim.style.display = ringGuideChk.checked ? 'block' : 'none');

    // ===== HUD hide/show
    let hudHidden = false;
    function setHUD(hidden) {
      hudHidden = hidden;
      document.getElementById('topbar').style.display = hidden ? 'none' : 'flex';
      document.getElementById('bottombar').style.display = hidden ? 'none' : 'flex';
      aim.style.display = hidden ? 'none' : (ringGuideChk.checked ? 'block' : 'none');
      hideUiBtn.textContent = hidden ? 'Show UI' : 'Hide UI';
      showToast(hidden ? 'UI hidden (tap Show UI or press H)' : 'UI shown');
    }
    hideUiBtn.addEventListener('click', () => setHUD(!hudHidden));
    window.addEventListener('keydown', (e) => { if (e.key && e.key.toLowerCase() === 'h') setHUD(!hudHidden); });

    // ===== Camera helpers
    function isSecureContextOK(){
      return location.protocol === 'https:' || location.hostname === 'localhost';
    }
    async function canUseCamera(){
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return false;
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        return devices.some(d => d.kind === 'videoinput');
      } catch { return false; }
    }

    async function startCamera() {
      try {
        if (!isSecureContextOK()) {
          alert('Camera requires HTTPS (or localhost). Please host over HTTPS.');
          return;
        }
        if (!(await canUseCamera())) {
          alert('No camera found or permission blocked. On iPhone: Settings → Safari → Camera → Allow.');
          return;
        }
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        const constraints = {
          audio: false,
          video: {
            facingMode: useBack ? { ideal: 'environment' } : 'user',
            width: { ideal: 1920 }, height: { ideal: 1080 }
          }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        await video.play();
        showToast('Camera started');
      } catch (err) {
        console.error(err);
        if (err && (err.name === 'NotFoundError' || err.name === 'OverconstrainedError')) {
          alert('Requested camera not found. Try Flip, or enable camera in Settings.');
        } else if (err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')) {
          alert('Camera permission denied. On iPhone: Settings → Safari → Camera → Allow.');
        } else {
          alert('Unable to access camera. Use HTTPS and allow permission.');
        }
      }
    }

    function stopCamera() { if (currentStream) currentStream.getTracks().forEach(t => t.stop()); }

    startBtn.addEventListener('click', startCamera);
    flipBtn.addEventListener('click', async () => { useBack = !useBack; await startCamera(); });

    // ===== Sample wheel (transparent PNG data URI)
    const SAMPLE_WHEEL =
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAACgCAYAAAB6m3qTAAABbklEQVR4nO3RMQEAIAwEsdP+v2Qp9g0wC8mKk5kH1mL8vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwEwDgY9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AABg9k0AAJ4BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwK3r1HAAEwE0GxAAAAAElFTkSuQmCC';

    sampleBtn.addEventListener('click', () => {
      wheel.src = SAMPLE_WHEEL;
      wheel.style.visibility = 'visible';
      updateWheelTransform();
      showToast('Sample wheel loaded');
    });

    // ===== File upload: use DataURL for iOS compatibility
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) { showToast('No file selected'); return; }
      const type = (f.type || '').toLowerCase();
      const name = (f.name || '').toLowerCase();
      if (name.endsWith('.heic') || name.endsWith('.heif') || type.includes('heic') || type.includes('heif')) {
        alert('HEIC/HEIF are not supported by browsers directly. Please export as PNG/JPG or set iPhone Camera → Formats → Most Compatible.');
        return;
      }
      if (type && !type.startsWith('image/')) {
        alert('Please upload an image file (PNG/JPG/WebP).');
        return;
      }
      const reader = new FileReader();
      reader.onerror = () => alert('Could not read image. Try a smaller file.');
      reader.onload = () => {
        wheel.onload = () => { wheel.style.visibility = 'visible'; updateWheelTransform(); };
        wheel.onerror = () => { wheel.style.visibility = 'hidden'; alert('Could not load image. Try PNG/JPG or a smaller file.'); };
        wheel.src = String(reader.result);
        showToast('Wheel loaded');
      };
      reader.readAsDataURL(f);
    });

    // ===== Gestures (drag, pinch, rotate)
    const active = new Map(); // pointerId -> {x,y}
    function onPointerDown(e) { try { wheel.setPointerCapture(e.pointerId); } catch(_) {} active.set(e.pointerId, { x: e.clientX, y: e.clientY }); }
    function onPointerMove(e) {
      if (!active.has(e.pointerId)) return;
      const prev = active.get(e.pointerId);
      active.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (active.size === 1) {
        if (!lockCenter.checked) { pos.x += e.clientX - prev.x; pos.y += e.clientY - prev.y; updateWheelTransform(); }
      } else if (active.size >= 2) {
        const ids = [...active.keys()].slice(0,2);
        const p0 = active.get(ids[0]);
        const p1 = active.get(ids[1]);
        const p0Prev = ids[0] === e.pointerId ? prev : p0;
        const p1Prev = p1;
        const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
        const ang = (a,b)=>Math.atan2(b.y-a.y, b.x-a.x);
        const dNow = dist(p0,p1), dPrev = dist(p0Prev,p1Prev);
        if (dPrev > 0) scale = Math.min(2, Math.max(0.2, scale * (dNow/dPrev)));
        const aNow = ang(p0,p1), aPrev = ang(p0Prev,p1Prev);
        const deltaDeg = (aNow - aPrev) * 180 / Math.PI;
        rotate.value = (((Number(rotate.value) + deltaDeg) % 360) + 360) % 360;
        updateWheelTransform();
      }
    }
    function onPointerUp(e) { active.delete(e.pointerId); }

    wheel.addEventListener('pointerdown', onPointerDown);
    wheel.addEventListener('pointermove', onPointerMove);
    wheel.addEventListener('pointerup', onPointerUp);
    wheel.addEventListener('pointercancel', onPointerUp);

    // ===== Snapshot (composite camera + wheel)
    snapBtn.addEventListener('click', async () => {
      if (!video.videoWidth) return alert('Camera not ready.');
      const cw = capture.width, ch = capture.height;
      const ctx = capture.getContext('2d');
      ctx.clearRect(0,0,cw,ch);
      const vW = video.videoWidth, vH = video.videoHeight;
      const canvasAR = cw / ch, videoAR = vW / vH;
      let sx, sy, sw, sh;
      if (videoAR > canvasAR) { sh = vH; sw = vH * canvasAR; sx = (vW - sw)/2; sy = 0; }
      else { sw = vW; sh = vW / canvasAR; sx = 0; sy = (vH - sh)/2; }
      ctx.save(); if (mirrorChk.checked) { ctx.translate(cw, 0); ctx.scale(-1, 1); }
      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, cw, ch); ctx.restore();
      const w = window.innerWidth, h = window.innerHeight;
      const minDim = Math.min(w, h);
      const dim = minDim * (Number(size.value)/100) * scale;
      const cx = cw/2 + (lockCenter.checked ? 0 : pos.x * (cw/w));
      const cy = ch/2 + (lockCenter.checked ? 0 : pos.y * (ch/h));
      const img = wheel;
      if (img && img.complete && img.naturalWidth) {
        ctx.save(); ctx.globalAlpha = Number(opacity.value)/100; ctx.translate(cx, cy); ctx.rotate(Number(rotate.value) * Math.PI/180); ctx.drawImage(img, -dim/2, -dim/2, dim, dim); ctx.restore();
      }
      const data = capture.toDataURL('image/png');
      const a = document.createElement('a'); a.href = data; a.download = `wheel-sim-${Date.now()}.png`; a.click();
      showToast('Snapshot saved');
    });

    // ===== Reset
    resetBtn.addEventListener('click', () => {
      pos = { x: 0, y: 0 }; scale = 0.7; rotate.value = 0; size.value = 70; opacity.value = 100; wheel.style.visibility = 'hidden'; updateWheelTransform(); showToast('Reset');
      if (hudHidden) setHUD(false);
    });

    // ===== Toast
    function showToast(msg) { toast.textContent = msg; toast.style.display = 'block'; clearTimeout(showToast._t); showToast._t = setTimeout(()=> toast.style.display='none', 1500); }

    // ===== Initial state
    const EMPTY_PIXEL = 'data:image/gif;base64,R0lGODlhAQABAAAAACw='; // 1x1 transparent
    wheel.src = EMPTY_PIXEL; wheel.style.visibility = 'hidden'; updateWheelTransform();
    window.addEventListener('resize', updateWheelTransform);

    // ===== Self tests (do not remove; add new tests below as needed)
    (function selfTest(){
      try {
        console.group('AR Wheel Overlay — Self Test');
        console.assert(video instanceof HTMLVideoElement, 'video element exists');
        console.assert(wheel instanceof HTMLImageElement, 'wheel image exists');
        const before = wheel.style.transform; rotate.value = 15; updateWheelTransform();
        console.assert(wheel.style.transform !== before, 'transform updates when controls change');
        const img = new Image(); img.onload = () => console.assert(img.naturalWidth > 0, 'sample wheel data URI loads'); img.src = SAMPLE_WHEEL;
        // HUD toggle tests
        setHUD(true); console.assert(document.getElementById('topbar').style.display === 'none', 'HUD hides');
        setHUD(false); console.assert(document.getElementById('topbar').style.display !== 'none', 'HUD shows');
        // Camera capability preflight (non-fatal)
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          navigator.mediaDevices.enumerateDevices().then(list => {
            console.assert(Array.isArray(list), 'enumerateDevices returns an array');
          }).catch(()=>{});
        }
        console.groupEnd();
      } catch (e) { console.error('Self test failed', e); }
    })();

    // Notes: iOS requires HTTPS and a user gesture (Start Camera) for getUserMedia.
  </script>
</body>
</html>
